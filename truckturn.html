<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Vehicle Physics Simulator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e);
            color: white;
            overflow: hidden;
        }
        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #0066ff;
            backdrop-filter: blur(10px);
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        select {
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid #0066ff;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
        }
        select option {
            background: #1a1a2e;
            color: white;
        }
        .speed-display {
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
        }
        .instructions {
            font-size: 12px;
            line-height: 1.4;
            color: #aaa;
            margin-top: 15px;
        }
        canvas {
            display: block;
            background: #1a4a1a;
            cursor: crosshair;
        }
        .warning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            display: none;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div class="hud">
        <div class="controls">
            <div class="control-group">
                <label>Vehicle:</label>
                <select id="vehicleType">
                    <option value="car">Car</option>
                    <option value="rigidTruck">Rigid Truck</option>
                    <option value="semiTrailer">Semi-trailer</option>
                    <option value="bdouble">B-Double</option>
                    <option value="roadTrain">Road Train</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Scenario:</label>
                <select id="scenario">
                    <option value="intersection">City Intersection</option>
                    <option value="roundabout">Roundabout</option>
                    <option value="highway">Highway Curves</option>
                </select>
            </div>
            
            <div class="speed-display">
                Throttle: <span id="speedValue">0</span>%
            </div>
        </div>
        
        <div class="instructions">
            <strong>Controls:</strong><br>
            • WASD or Arrow Keys to drive<br>
            • Hold SHIFT for slower turning<br>
            • Space bar to brake<br>
            <br>
            <strong>Notice:</strong><br>
            • Trailers cut corners (off-tracking)<br>
            • Longer vehicles need wider turns<br>
            • Speed affects handling drastically
        </div>
    </div>
    
    <div class="warning" id="collisionWarning" style="display: none;">
        COLLISION!
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Resize canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let keys = {};
        let vehicle = null;
        let currentScenario = 'intersection';
        let camera = { x: 0, y: 0 };
        let collisionWarning = false;
        let collisionWarningTime = 0;

        // Input handling
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false;
        });

        // Vehicle physics class
        class VehicleSegment {
            constructor(x, y, length, width, color, isTrailer = false, hitchOffset = 0) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.length = length;
                this.width = width;
                this.color = color;
                this.isTrailer = isTrailer;
                this.hitchOffset = hitchOffset; // Distance from rear to hitch point
                this.velocity = { x: 0, y: 0 };
                this.angularVelocity = 0;
            }

            update(dt) {
                // Apply velocity
                this.x += this.velocity.x * dt;
                this.y += this.velocity.y * dt;
                this.angle += this.angularVelocity * dt;
                
                // Normalize angle
                while (this.angle > Math.PI) this.angle -= 2 * Math.PI;
                while (this.angle < -Math.PI) this.angle += 2 * Math.PI;
            }

            getHitchPoint() {
                const hitchX = this.x - Math.cos(this.angle) * this.hitchOffset;
                const hitchY = this.y - Math.sin(this.angle) * this.hitchOffset;
                return { x: hitchX, y: hitchY };
            }

            getFrontPoint() {
                const frontX = this.x + Math.cos(this.angle) * (this.length / 2);
                const frontY = this.y + Math.sin(this.angle) * (this.length / 2);
                return { x: frontX, y: frontY };
            }

            getRearPoint() {
                const rearX = this.x - Math.cos(this.angle) * (this.length / 2);
                const rearY = this.y - Math.sin(this.angle) * (this.length / 2);
                return { x: rearX, y: rearY };
            }

            getCorners() {
                const corners = [];
                const halfLength = this.length / 2;
                const halfWidth = this.width / 2;
                
                for (let i = 0; i < 4; i++) {
                    const localX = (i < 2) ? halfLength : -halfLength;
                    const localY = (i === 0 || i === 3) ? halfWidth : -halfWidth;
                    
                    const worldX = this.x + localX * Math.cos(this.angle) - localY * Math.sin(this.angle);
                    const worldY = this.y + localX * Math.sin(this.angle) + localY * Math.cos(this.angle);
                    
                    corners.push({ x: worldX, y: worldY });
                }
                return corners;
            }

            draw(ctx, camera) {
                ctx.save();
                ctx.translate(this.x - camera.x, this.y - camera.y);
                ctx.rotate(this.angle);
                
                // Main body with gradient
                const gradient = ctx.createLinearGradient(0, -this.width/2, 0, this.width/2);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(0.5, this.lightenColor(this.color, 20));
                gradient.addColorStop(1, this.darkenColor(this.color, 20));
                
                ctx.fillStyle = gradient;
                ctx.fillRect(-this.length/2, -this.width/2, this.length, this.width);
                
                // Border
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.length/2, -this.width/2, this.length, this.width);
                
                if (!this.isTrailer) {
                    // Draw cab details
                    ctx.fillStyle = '#222';
                    ctx.fillRect(this.length/2 - 15, -this.width/2 + 3, 12, this.width - 6);
                    
                    // Windshield
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(this.length/2 - 12, -this.width/2 + 6, 8, this.width - 12);
                    
                    // Headlights
                    ctx.fillStyle = '#FFFF88';
                    ctx.fillRect(this.length/2 - 2, -this.width/2, 4, 4);
                    ctx.fillRect(this.length/2 - 2, this.width/2 - 4, 4, 4);
                } else {
                    // Trailer details
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 1;
                    for (let i = 1; i < 4; i++) {
                        const x = -this.length/2 + (this.length * i / 4);
                        ctx.beginPath();
                        ctx.moveTo(x, -this.width/2);
                        ctx.lineTo(x, this.width/2);
                        ctx.stroke();
                    }
                }
                
                // Wheels
                ctx.fillStyle = '#111';
                const wheelSize = 6;
                const wheelPositions = this.isTrailer ? 
                    [[-this.length/3, -this.width/2 - 2], [-this.length/3, this.width/2 + 2], 
                     [this.length/3, -this.width/2 - 2], [this.length/3, this.width/2 + 2]] :
                    [[-this.length/4, -this.width/2 - 2], [-this.length/4, this.width/2 + 2],
                     [this.length/4, -this.width/2 - 2], [this.length/4, this.width/2 + 2]];
                
                wheelPositions.forEach(([x, y]) => {
                    ctx.fillRect(x - wheelSize/2, y - wheelSize/2, wheelSize, wheelSize);
                });
                
                ctx.restore();
                
                // Draw hitch point for debugging
                if (this.isTrailer) {
                    const hitch = this.getHitchPoint();
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(hitch.x - camera.x, hitch.y - camera.y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            lightenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }

            darkenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                return "#" + (0x1000000 + (R > 255 ? 255 : R < 0 ? 0 : R) * 0x10000 +
                    (G > 255 ? 255 : G < 0 ? 0 : G) * 0x100 +
                    (B > 255 ? 255 : B < 0 ? 0 : B)).toString(16).slice(1);
            }
        }

        class Vehicle {
            constructor(config) {
                this.segments = [];
                this.throttle = 0;
                this.maxThrottle = 100;
                this.throttleRate = 200; // Throttle response rate
                this.trail = []; // For showing path
                this.trailTimer = 0;
                
                // Create vehicle segments with proper spacing
                let currentX = canvas.width / 2;
                let currentY = canvas.height / 2;
                
                config.segments.forEach((segConfig, index) => {
                    const segment = new VehicleSegment(
                        currentX, 
                        currentY, 
                        segConfig.length, 
                        segConfig.width, 
                        segConfig.color, 
                        index > 0,
                        segConfig.hitchOffset || segConfig.length / 2
                    );
                    
                    this.segments.push(segment);
                    // Properly space segments to prevent initial overlap
                    currentX -= segConfig.length + (segConfig.gap || 15);
                });
                
                // Set proper initial positions for articulated vehicles
                if (this.segments.length > 1) {
                    this.repositionTrailers();
                }
            }

            repositionTrailers() {
                // Position each trailer behind the previous segment at correct distance
                for (let i = 1; i < this.segments.length; i++) {
                    const tractor = this.segments[i - 1];
                    const trailer = this.segments[i];
                    
                    // Calculate proper position behind tractor
                    const spacing = 15; // Gap between segments
                    const tractorRear = tractor.getRearPoint();
                    
                    trailer.x = tractorRear.x - Math.cos(tractor.angle) * (trailer.hitchOffset + spacing);
                    trailer.y = tractorRear.y - Math.sin(tractor.angle) * (trailer.hitchOffset + spacing);
                    trailer.angle = tractor.angle;
                }
            }

            update(dt) {
                const cabSegment = this.segments[0];
                
                // Input handling
                let accelerating = keys['w'] || keys['arrowup'];
                let reversing = keys['s'] || keys['arrowdown'];
                let turningLeft = keys['a'] || keys['arrowleft'];
                let turningRight = keys['d'] || keys['arrowright'];
                let braking = keys[' '] || keys['space'];
                let slowTurn = keys['shift'];
                
                // Throttle control (more realistic)
                if (accelerating && !reversing) {
                    this.throttle = Math.min(this.throttle + this.throttleRate * dt, this.maxThrottle);
                } else if (reversing && !accelerating) {
                    this.throttle = Math.max(this.throttle - this.throttleRate * dt, -this.maxThrottle * 0.6);
                } else if (braking) {
                    this.throttle *= Math.pow(0.01, dt); // Hard braking
                } else {
                    // Natural throttle decay when no input
                    this.throttle *= Math.pow(0.7, dt);
                }
                
                // Convert throttle to actual speed (more realistic power curve)
                const maxSpeed = 80; // Reduced max speed
                const speed = (this.throttle / 100) * maxSpeed;
                
                // Turning (only when moving)
                if (Math.abs(speed) > 1) {
                    const turnMultiplier = slowTurn ? 0.3 : 1.0;
                    const speedFactor = Math.min(1.0, Math.abs(speed) / 20);
                    const actualTurnRate = 1.5 * turnMultiplier * speedFactor;
                    
                    if (turningLeft) {
                        cabSegment.angularVelocity = -actualTurnRate;
                    } else if (turningRight) {
                        cabSegment.angularVelocity = actualTurnRate;
                    } else {
                        cabSegment.angularVelocity = 0; // Stop turning immediately when keys released
                    }
                } else {
                    cabSegment.angularVelocity = 0;
                }
                
                // Update cab physics
                cabSegment.velocity.x = Math.cos(cabSegment.angle) * speed;
                cabSegment.velocity.y = Math.sin(cabSegment.angle) * speed;
                cabSegment.update(dt);
                
                // Update trailer physics with proper constraints
                for (let i = 1; i < this.segments.length; i++) {
                    const trailer = this.segments[i];
                    const tractor = this.segments[i - 1];
                    
                    // Get connection points
                    const tractorHitch = tractor.getRearPoint();
                    const trailerHitch = trailer.getHitchPoint();
                    
                    // Calculate required trailer position
                    const dx = tractorHitch.x - trailerHitch.x;
                    const dy = tractorHitch.y - trailerHitch.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const targetDistance = 10; // Desired hitch distance
                    
                    // Constrain trailer position
                    if (distance > targetDistance + 0.1) {
                        // Move trailer closer
                        const moveRatio = (distance - targetDistance) / distance;
                        trailer.x += dx * moveRatio * 0.8;
                        trailer.y += dy * moveRatio * 0.8;
                    } else if (distance < targetDistance - 0.1) {
                        // Push trailer away (prevent overlap)
                        const moveRatio = (targetDistance - distance) / distance;
                        trailer.x -= dx * moveRatio;
                        trailer.y -= dy * moveRatio;
                    }
                    
                    // Calculate trailer angle based on hitch constraint
                    const hitchAngle = Math.atan2(dy, dx);
                    const targetAngle = hitchAngle + Math.PI; // Trailer points opposite to hitch vector
                    
                    // Smooth angle transition
                    let angleDiff = targetAngle - trailer.angle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    trailer.angle += angleDiff * Math.min(1.0, 8.0 * dt);
                    
                    // Update trailer velocity to match its movement
                    const prevX = trailer.x;
                    const prevY = trailer.y;
                    trailer.update(dt);
                    trailer.velocity.x = (trailer.x - prevX) / dt;
                    trailer.velocity.y = (trailer.y - prevY) / dt;
                }
                
                // Add to trail
                this.trailTimer += dt;
                if (this.trailTimer > 0.1) {
                    this.segments.forEach(segment => {
                        this.trail.push({
                            x: segment.x,
                            y: segment.y,
                            time: Date.now()
                        });
                    });
                    this.trailTimer = 0;
                }
                
                // Clean old trail points
                const now = Date.now();
                this.trail = this.trail.filter(point => now - point.time < 5000);
                
                // Update camera to follow vehicle
                camera.x = cabSegment.x - canvas.width / 2;
                camera.y = cabSegment.y - canvas.height / 2;
                
                // Update throttle display
                document.getElementById('speedValue').textContent = Math.round(Math.abs(this.throttle));
            }

            checkCollisions(obstacles) {
                // Collision checking removed - no more annoying alarms
                return false;
            }

            draw(ctx) {
                // Draw trail
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    const screenX = point.x - camera.x;
                    const screenY = point.y - camera.y;
                    
                    if (i === 0) {
                        ctx.moveTo(screenX, screenY);
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                }
                ctx.stroke();
                
                // Draw vehicle segments
                this.segments.forEach(segment => segment.draw(ctx, camera));
            }
        }

        // Vehicle configurations
        const vehicleConfigs = {
            car: {
                segments: [
                    { length: 60, width: 30, color: '#ff4444', hitchOffset: 30 }
                ]
            },
            rigidTruck: {
                segments: [
                    { length: 100, width: 35, color: '#ff8844', hitchOffset: 50 }
                ]
            },
            semiTrailer: {
                segments: [
                    { length: 80, width: 35, color: '#ff8844', hitchOffset: 40 },
                    { length: 160, width: 35, color: '#4488ff', hitchOffset: 80, gap: 15 }
                ]
            },
            bdouble: {
                segments: [
                    { length: 80, width: 35, color: '#ff8844', hitchOffset: 40 },
                    { length: 140, width: 35, color: '#4488ff', hitchOffset: 70, gap: 15 },
                    { length: 140, width: 35, color: '#44ff88', hitchOffset: 70, gap: 15 }
                ]
            },
            roadTrain: {
                segments: [
                    { length: 80, width: 35, color: '#ff8844', hitchOffset: 40 },
                    { length: 160, width: 35, color: '#4488ff', hitchOffset: 80, gap: 15 },
                    { length: 160, width: 35, color: '#44ff88', hitchOffset: 80, gap: 15 },
                    { length: 160, width: 35, color: '#ff44ff', hitchOffset: 80, gap: 15 }
                ]
            }
        };

        // Scenarios
        function drawScenario(scenarioType) {
            const obstacles = [];
            
            ctx.fillStyle = '#1a4a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            
            for (let x = -camera.x % gridSize; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = -camera.y % gridSize; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            if (scenarioType === 'intersection') {
                // Draw intersection
                const centerX = 500 - camera.x;
                const centerY = 400 - camera.y;
                const roadWidth = 100;
                
                // Roads
                ctx.fillStyle = '#333';
                ctx.fillRect(centerX - roadWidth/2, 0, roadWidth, canvas.height);
                ctx.fillRect(0, centerY - roadWidth/2, canvas.width, roadWidth);
                
                // Lane markings
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.setLineDash([20, 20]);
                
                // Vertical road center line
                ctx.beginPath();
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, centerY - roadWidth/2);
                ctx.moveTo(centerX, centerY + roadWidth/2);
                ctx.lineTo(centerX, canvas.height);
                ctx.stroke();
                
                // Horizontal road center line
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(centerX - roadWidth/2, centerY);
                ctx.moveTo(centerX + roadWidth/2, centerY);
                ctx.lineTo(canvas.width, centerY);
                ctx.stroke();
                
                ctx.setLineDash([]);
                
                // Corner obstacles (buildings)
                const buildingSize = 80;
                obstacles.push(
                    { x: centerX - roadWidth/2 - buildingSize, y: centerY - roadWidth/2 - buildingSize, width: buildingSize, height: buildingSize },
                    { x: centerX + roadWidth/2, y: centerY - roadWidth/2 - buildingSize, width: buildingSize, height: buildingSize },
                    { x: centerX - roadWidth/2 - buildingSize, y: centerY + roadWidth/2, width: buildingSize, height: buildingSize },
                    { x: centerX + roadWidth/2, y: centerY + roadWidth/2, width: buildingSize, height: buildingSize }
                );
            } else if (scenarioType === 'roundabout') {
                const centerX = 500 - camera.x;
                const centerY = 400 - camera.y;
                const outerRadius = 120;
                const innerRadius = 60;
                
                // Roundabout
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, 0, 2 * Math.PI);
                ctx.fill();
                
                // Center island
                ctx.fillStyle = '#2a5a2a';
                ctx.beginPath();
                ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI);
                ctx.fill();
                
                // Approach roads
                const roadWidth = 80;
                ctx.fillStyle = '#333';
                ctx.fillRect(centerX - roadWidth/2, 0, roadWidth, centerY - outerRadius);
                ctx.fillRect(centerX - roadWidth/2, centerY + outerRadius, roadWidth, canvas.height - (centerY + outerRadius));
                ctx.fillRect(0, centerY - roadWidth/2, centerX - outerRadius, roadWidth);
                ctx.fillRect(centerX + outerRadius, centerY - roadWidth/2, canvas.width - (centerX + outerRadius), roadWidth);
            } else if (scenarioType === 'highway') {
                // Highway with curves
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 120;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(0, 400 - camera.y);
                
                for (let x = 0; x < 2000; x += 10) {
                    const worldX = x;
                    const worldY = 400 + 100 * Math.sin(worldX / 200) * Math.sin(worldX / 500);
                    ctx.lineTo(worldX - camera.x, worldY - camera.y);
                }
                ctx.stroke();
                
                // Center line
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.setLineDash([30, 30]);
                ctx.beginPath();
                ctx.moveTo(0, 400 - camera.y);
                
                for (let x = 0; x < 2000; x += 10) {
                    const worldX = x;
                    const worldY = 400 + 100 * Math.sin(worldX / 200) * Math.sin(worldX / 500);
                    ctx.lineTo(worldX - camera.x, worldY - camera.y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw obstacles
            ctx.fillStyle = '#8B4513';
            obstacles.forEach(obstacle => {
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            });
            
            return obstacles;
        }

        // Initialize vehicle
        function createVehicle() {
            const type = document.getElementById('vehicleType').value;
            vehicle = new Vehicle(vehicleConfigs[type]);
        }

        // Event listeners
        document.getElementById('vehicleType').addEventListener('change', createVehicle);
        document.getElementById('scenario').addEventListener('change', (e) => {
            currentScenario = e.target.value;
        });

        // Game loop
        let lastTime = 0;
        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.016); // Cap at 60 FPS
            lastTime = timestamp;
            
            const obstacles = drawScenario(currentScenario);
            
            if (vehicle) {
                vehicle.update(dt);
                vehicle.draw(ctx);
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Start the simulation
        createVehicle();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
